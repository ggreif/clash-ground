* How application is normally done

#+begin_src ditaa :file app.svg

          /--\
          |ap|
          +--+
         /    \
        f      a

#+end_src

* Either of both sub-nodes can be a variable

so let's special case those!

 - app_tree_tree
 - app_v_tree
 - app_tree_v
 - app_v_v

* But we still need to store the vars, right?

With De Bruijn it is easier, but still...

Consider:

#+begin_src ditaa :file app.svg

          /--\
          |ap|
          \--+
              \
        f?     a

#+end_src

How can we say which /f/ is meant?

Solution: store the De Bruijn index in the /ap/ node but at the type level!

* The /app_v_v/ case

The first v has index 0, the second /n/. So we need flipped /app/: /ppa/


#+begin_src ditaa :file app.svg

          /--\             /--\
          |ap|      ===    |pa|
          \--/             \--/

        f      a         a      f

#+end_src

* Summing up

We can always flip now the constructor to get the variable
with the lower De Bruijn index to the front, and transitively
we can make sure that the in-order traversal will yield
a "mostly increasing" indexing pattern, better suited for
FPGA implementation because of shorter substitution templates.

* Can we enforce this statically?

Idea: Encode the /monotonically increasing/ De Bruijn indices as a GADT.
      This will validate the concept.

** Trouble
I expect that we are in trouble when the following case arises:
#+begin_src haskell
(v1 (v0 v2))
#+end_src

** How can we resolve the trouble?

As some =(t1 `app` t2)= situations unavoidably lead to non-monotonic variable arrangements,
how can we salvage the situation?

I propose a simple solution: when for a subtree monotonicity is impossible to achieve
by flipping the application, then make that subtree /indirect/, i.e. eta-expand it and
assign it to another heap cell or range, leaving a /pointer to the lambda/ behind.
The remaining lambdas then both can be monotonic, and thus block-like or inline, but
this time we need to deal with the additional possibility of pointers.


Consider:
#+BEGIN_SRC haskell
\a b c d . ((a c) (d b))
#+END_SRC
  /flip second tree/
#+BEGIN_SRC haskell
\a b c d . ((a c) (b <-> d))
#+END_SRC
  /outline second tree/
#+BEGIN_SRC haskell
\a c . ((a c) v)
              v
              v
              \b d . (b <-> d)
#+END_SRC
